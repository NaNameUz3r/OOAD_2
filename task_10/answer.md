В python можно запрещать переопредление методов класса, или наследование класса целиком с помощью декоратора @final

```
class Egg:
    @final
    def Exists(self):
        pass

class Chicken(Base):
    # На запуске интерпретатор упадет с ошибкой:
    # error: Cannot override final attribute "Exists"
    #  (previously declared in base class "Egg")
    def Exists(self):
        pass
```

```
@final
class Egg: ...

# error: Cannot inherit from final class "Egg"
class Chicken(Egg): ...
```


Что касаемо Golang, насколько я понимаю, в привычном ООП понимании здесь отсутствует как таковая возможность переопределения метода, потому что нет наследования классов\структур. Каждый АТД\Стракт может именть набор методов, где конкретный стракт выступает ресивером. Разные стракты могут реализовать один и тот же метод, и иметь, как следствие, набор методов с одинаковыми именами, но это совсем разные сущности и говорить о наследовании тут нельзя.