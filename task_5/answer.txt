С некоторыми оговорками, и при условии, что модуле, как о базовой синтаксической единице, в Python поддерживаются почти все принципы.
 
1. Новый модуль может задавать некоторый базовый тип, 
который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики):

    ДА! Python динамически типизируемый яп, в стандартной библиотеке есть библиотека typing для создания дженериков
    (аннотирование типов). И ещё, опять же, с оговорками, но по сути модуль задающий базовый тип может параметризоваться
    переменными на уровне модуля или аргументами функции. Всю эта "типизация" всё равно требует либо отдельного внимания
    программиста либо внешние инструменты (тайп чекеры, вроде mypy)

2. Новый модуль может объединять несколько функций, которые активно обращаются
   друг к другу;

    ДА! Модуль как "файл" объединяет в одно пространство видимости все функции, которые в нем находятся.
        Модуль как класс объединяет в пространстве своей видимости функции-методы, которые так же "видят" друг друга.


3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля; 

    ДА! Несколько модулей можно объединять в пакет. Например, если в один модуль мы импортируем несколько других модулей, что это, как не организация семейства?


4. Новый модуль может предлагать конкретную реализацию родительского модуля, 
которая должна выбираться динамически (полиморфно) -- например, 
реализация обобщённого типа для конкретного типа-параметра; 

    Скорее, нет... Динамически определить реализацию родительского модуля тут нельзя, её нужно определять программисту, переопределяя\дополняя родительский модуль
    в сабмодуле.


5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями. 

    Скорее да. Общее поведение может быть определено в базовом модуле (модулях) и расширено в других модулях посредством наследования, в том числе множественного.


---

Что же касаемо Go... Что-ж, это "не ООП язык", как часто можно услышать. Тем не менее дженерики с недавних пор появились :)

1. Новый модуль может задавать базовый тип, и да, теперь, потенциально, он может допускать параметризацию другими типами! 
2. разумеется, новый модуль может обхядинять несколько функций которые друг друга "видят" и могут вызывать.
3. Да! Модуль(пакет) может входить в семейство модулей(пакетов), потенциально с неограниченной степенью вложенности, хотя на практике стоит ограничиться
несколькими уровнями. Единственный важный момент тут — компилятор не пропустит пакеты(модули) с циклическими зависимостями.
4. Скорее нет. В рамках одного модуля мы можем принимать интерфейс как параметр, и воспользоваться type assertion в реализации некоторой логики, но на уровне
модуля как базовой синтаксической единицы, похоже что такая "динамическяа реализация" невозможна.
5. Да, мы можем массово импортировать несколько других модулей.

