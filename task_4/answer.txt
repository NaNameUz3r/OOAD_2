Возьмем затертый пример -- Иерархия классов транспортных средств.

    Базовый класс: Vehicle
        Базовый класс Vehicle открыт для расширения, потому что новые типы транспортных средств могут добавляться как подклассы без измнения базового класса.
        Тогда как реализация базового классе должна быть скрыта, то некоторые методы, например метод вычисления времени путешествия будет открыт
        для расширения. Подклассы базового метода могут перегружать этот метод с имплементаций собственной логики вычисления времени путешествия, и тд.
        Детали реализации базового класса должны быть "скрыты от расширения", потому что изменение изменят "поведение" всех классов-наследников, что может, и скорее всего
        приведет к непредвиденным изменениям в системе (например её полной неработоспособности :)

    Подклассы: Car, Boat, Airplane
    Под-подклассы: Sedan, SUV, Motorboat, и так далее.
        Конкретние подклассы базового класса и их "под-подклассы" открыты для расширения, потому что могут добавляться новые, конкретные модели транспортных средств без изменения их родительских классов.
        Тут, открытым методом, может быть, например, метод расчета потребления топлива, который снова будет перегружаться и имплементироваться по разному Машиной-седаном и моторной лодкой.
        Глубина иерархии здесь не рассматривается и зависит от дизайна системы классов.
    
    Любые классы-наследники, имплементирующие конкретные брэнды и модели транспортных средств.
        Все эти классы должны быть закрыты, потому что представляют конкретную "транспортную" сущность. Любые изменения в имплементацию такой конкретной "модели" потребуют внесения изменений
        в родительские "подклассы", что противоречит OCP. 
        Сохраняя эти классы закрытыми мы поддерживаем код стабильным и обслуживаемым, так как детали реализации конкретной "модели" никак не влияют на другие части программы.
        Хорошо спроекированная таким образом система классов позволяет легко расширять систему, добавляя новые транспортные средства без внесения правок (или без внесения существенных правок, в идеале вообще
        внесения правок только в одно место) в существующий код. 
     